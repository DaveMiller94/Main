
from __future__ import annotations
import math
import pandas as pd
from collections import deque, defaultdict
from typing import Dict, List, Tuple

def _round_units(units: float, dp: int) -> float:
    return round(units, dp)

def _ensure_series_nav_consistency(df: pd.DataFrame, key_cols=("sedol",)) -> None:
    for keys, g in df.groupby(list(key_cols), sort=False):
        navs = pd.to_numeric(g["nav"], errors="coerce").dropna().unique().tolist()
        if len(navs) != 1:
            raise ValueError(f"Multiple NAVs detected for {key_cols}={keys}: {navs}. Provide a single NAV per SEDOL.")

def _compute_row_target_value(row: pd.Series) -> float:
    if pd.notnull(row.get("target_value")):
        return float(row["target_value"])
    if pd.notnull(row.get("target_weight")) and pd.notnull(row.get("portfolio_value")):
        return float(row["target_weight"]) * float(row["portfolio_value"])
    return float("nan")

def _resolve_fund_targets(holdings: pd.DataFrame) -> pd.DataFrame:
    need_cols = {"client_id","fund_id"}
    if not need_cols.issubset(set(holdings.columns)):
        raise ValueError("Holdings must contain client_id and fund_id.")

    df = holdings.copy()
    if "fund_target_value" in df.columns and df["fund_target_value"].notna().any():
        fund_targets = df.groupby(["client_id","fund_id"], sort=False)["fund_target_value"].max().reset_index()
        fund_targets.rename(columns={"fund_target_value":"fund_target_value_resolved"}, inplace=True)
        return fund_targets

    if {"fund_target_weight","portfolio_value"}.issubset(set(df.columns)) and df["fund_target_weight"].notna().any():
        tmp = df.copy()
        tmp["__ftv__"] = tmp["fund_target_weight"] * tmp["portfolio_value"]
        fund_targets = tmp.groupby(["client_id","fund_id"], sort=False)["__ftv__"].max().reset_index()
        fund_targets.rename(columns={"__ftv__":"fund_target_value_resolved"}, inplace=True)
        return fund_targets

    if "target_value" not in df.columns:
        if {"target_weight","portfolio_value"}.issubset(set(df.columns)):
            df["target_value"] = df.apply(_compute_row_target_value, axis=1)
        else:
            raise ValueError("Provide either fund-level targets or row-level (target_value or target_weight & portfolio_value).")

    fund_targets = df.groupby(["client_id","fund_id"], sort=False)["target_value"].sum().reset_index()
    fund_targets.rename(columns={"target_value":"fund_target_value_resolved"}, inplace=True)
    return fund_targets

def _greedy_match(
    buyers: List[Dict], sellers: List[Dict], price: float, unit_dp: int, min_ticket_value: float, reason: str
) -> Tuple[List[Dict], List[Dict], List[Dict], Dict[str, float]]:
    buyers_q = deque(sorted(buyers, key=lambda x: x["remaining_value"], reverse=True))
    sellers_q = deque(sorted(sellers, key=lambda x: x["remaining_value"], reverse=True))
    txns = []
    deltas: Dict[str, float] = {}

    while buyers_q and sellers_q:
        b = buyers_q[0]
        s = sellers_q[0]
        trade_value_raw = min(b["remaining_value"], s["remaining_value"])

        if trade_value_raw < max(min_ticket_value, 0.0):
            if b["remaining_value"] <= s["remaining_value"]:
                buyers_q.popleft()
            else:
                sellers_q.popleft()
            continue

        units = trade_value_raw / price if price != 0 else 0.0
        units = _round_units(units, unit_dp)
        if units <= 0:
            if b["remaining_value"] <= s["remaining_value"]:
                buyers_q.popleft()
            else:
                sellers_q.popleft()
            continue

        trade_value = units * price
        b["remaining_value"] -= trade_value
        s["remaining_value"] -= trade_value

        txns.append({
            "from_client": s["client_id"],
            "to_client": b["client_id"],
            "price": price,
            "units": units,
            "value": trade_value,
            "reason": reason
        })

        deltas[b["client_id"]] = deltas.get(b["client_id"], 0.0) + trade_value
        deltas[s["client_id"]] = deltas.get(s["client_id"], 0.0) - trade_value

        if b["remaining_value"] <= 1e-9: buyers_q.popleft()
        if s["remaining_value"] <= 1e-9: sellers_q.popleft()

    buyers_resid = [x for x in list(buyers_q) if x["remaining_value"] > 1e-9]
    sellers_resid = [x for x in list(sellers_q) if x["remaining_value"] > 1e-9]
    return txns, buyers_resid, sellers_resid, deltas

def run_matching_engine_twofile_fundlevel(
    blotter_csv: str,
    holdings_csv: str,
    transactions_out: str = "transactions_internal.csv",
    external_out: str = "net_external_per_sedol.csv",
    summary_out: str = "post_trade_summary.csv",
    unit_decimal_places: int = 6,
    min_ticket_value: float = 0.0
):
    blotter = pd.read_csv(blotter_csv)
    holdings = pd.read_csv(holdings_csv)

    req_blotter = {"client_id","sedol","fund_id","currency","nav","order_value"}
    if not req_blotter.issubset(set(blotter.columns)):
        raise ValueError(f"Blotter missing columns: {req_blotter - set(blotter.columns)}")
    req_hold_base = {"client_id","sedol","fund_id","currency","nav","position_value"}
    if not req_hold_base.issubset(set(holdings.columns)):
        raise ValueError(f"Holdings missing columns: {req_hold_base - set(holdings.columns)}")

    if "order_units" not in blotter.columns:
        blotter["order_units"] = pd.NA
    blotter["order_units"] = blotter.apply(
        lambda r: (float(r["order_value"]) / float(r["nav"])) if pd.isna(r["order_units"]) and r["nav"] != 0 else r["order_units"],
        axis=1
    )

    _ensure_series_nav_consistency(pd.concat([
        blotter[["sedol","nav"]],
        holdings[["sedol","nav"]]
    ], ignore_index=True), key_cols=("sedol",))

    fund_targets = _resolve_fund_targets(holdings)

    all_txns = []
    residuals_by_sedol = {}
    value_delta_sedol = defaultdict(lambda: defaultdict(float))

    for sedol, bgroup in blotter.groupby("sedol", sort=False):
        hgroup = holdings[holdings["sedol"] == sedol]
        if hgroup.empty:
            raise ValueError(f"No holdings rows for sedol={sedol}.")
        fund_id = hgroup["fund_id"].mode().iat[0]
        currency = hgroup["currency"].mode().iat[0]
        nav = float(pd.concat([bgroup["nav"], hgroup["nav"]]).dropna().unique()[0])

        buyers = [{"client_id": r.client_id, "remaining_value": max(float(r.order_value), 0.0)}
                  for r in bgroup.itertuples(index=False) if float(r.order_value) > 0]
        sellers = [{"client_id": r.client_id, "remaining_value": max(-float(r.order_value), 0.0)}
                   for r in bgroup.itertuples(index=False) if float(r.order_value) < 0]

        txns_flow, resid_buys, resid_sells, deltas = _greedy_match(
            buyers, sellers, nav, unit_decimal_places, min_ticket_value, reason="flow-net"
        )
        for t in txns_flow:
            t.update({"sedol": sedol, "fund_id": fund_id, "currency": currency})
        all_txns.extend(txns_flow)
        for k, v in deltas.items():
            value_delta_sedol[sedol][k] += v

        residuals_by_sedol[sedol] = {
            "resid_buys": resid_buys,
            "resid_sells": resid_sells,
            "nav": nav,
            "fund_id": fund_id,
            "currency": currency
        }

    pos0 = holdings.groupby(["client_id","fund_id","sedol"], sort=False)["position_value"].sum().reset_index()
    pos0_map = {(r.client_id, r.fund_id, r.sedol): float(r.position_value) for r in pos0.itertuples(index=False)}
    post_flow_map = {}
    for key, val in pos0_map.items():
        post_flow_map[key] = val
    for r in blotter.itertuples(index=False):
        key = (r.client_id, r.fund_id, r.sedol)
        post_flow_map.setdefault(key, 0.0)
    for sedol, deltas in value_delta_sedol.items():
        fid = holdings.loc[holdings["sedol"]==sedol, "fund_id"].mode().iat[0]
        for cid, dv in deltas.items():
            key = (cid, fid, sedol)
            post_flow_map[key] = post_flow_map.get(key, 0.0) + dv

    fund_totals = defaultdict(float)
    for (cid,fid,sed), val in post_flow_map.items():
        fund_totals[(cid,fid)] += val

    fund_target_map = {(r.client_id, r.fund_id): float(r.fund_target_value_resolved) for r in fund_targets.itertuples(index=False)}
    fund_dev = {}
    for (cid,fid), total_val in fund_totals.items():
        tgt = fund_target_map.get((cid,fid), 0.0)
        fund_dev[(cid,fid)] = total_val - tgt

    external_rows = []
    value_delta2 = defaultdict(lambda: defaultdict(float))

    for sedol, meta in residuals_by_sedol.items():
        resid_buys = meta["resid_buys"]
        resid_sells = meta["resid_sells"]
        nav = meta["nav"]; fund_id = meta["fund_id"]; currency = meta["currency"]

        if sum(x["remaining_value"] for x in resid_buys) > 1e-9:
            sellers_pool = []
            for (cid,fid,sed), val in list(post_flow_map.items()):
                if sed != sedol or fid != fund_id: continue
                if val <= 1e-9: continue
                ow = fund_dev.get((cid, fund_id), 0.0)
                if ow > 1e-9:
                    sellers_pool.append({"client_id": cid, "remaining_value": min(ow, val)})
            if sellers_pool:
                txns_ow, resid_buys2, resid_sells2, deltas2 = _greedy_match(
                    resid_buys, sellers_pool, nav, unit_decimal_places, min_ticket_value, reason="offset-overweight(fund)"
                )
                for t in txns_ow:
                    t.update({"sedol": sedol, "fund_id": fund_id, "currency": currency})
                for k, v in deltas2.items():
                    value_delta2[sedol][k] += v
                    post_flow_map[(k, fund_id, sedol)] = post_flow_map.get((k,fund_id,sedol),0.0) + v
                    fund_totals[(k,fund_id)] = fund_totals.get((k,fund_id),0.0) + v
                    tgt = fund_target_map.get((k,fund_id),0.0)
                    fund_dev[(k,fund_id)] = fund_totals[(k,fund_id)] - tgt
                all_txns.extend(txns_ow)
                resid_buy_after = sum(x["remaining_value"] for x in resid_buys2)
                if resid_buy_after > 1e-9:
                    units = round(resid_buy_after / nav, unit_decimal_places) if nav != 0 else 0.0
                    external_rows.append({
                        "sedol": sedol, "fund_id": fund_id, "currency": currency,
                        "side": "External Subscribe", "price": nav,
                        "units": units, "value": units * nav
                    })
            else:
                total_buy = sum(x["remaining_value"] for x in resid_buys)
                if total_buy > 1e-9:
                    units = round(total_buy / nav, unit_decimal_places) if nav != 0 else 0.0
                    external_rows.append({
                        "sedol": sedol, "fund_id": fund_id, "currency": currency,
                        "side": "External Subscribe", "price": nav,
                        "units": units, "value": units * nav
                    })

        if sum(x["remaining_value"] for x in resid_sells) > 1e-9:
            buyers_pool = []
            for (cid,fid), dev in fund_dev.items():
                if fid != fund_id: continue
                uw = -dev
                if uw > 1e-9:
                    buyers_pool.append({"client_id": cid, "remaining_value": uw})
            if buyers_pool:
                txns_uw, resid_buys2, resid_sells2, deltas2 = _greedy_match(
                    buyers_pool, resid_sells, nav, unit_decimal_places, min_ticket_value, reason="offset-underweight(fund)"
                )
                for t in txns_uw:
                    t.update({"sedol": sedol, "fund_id": fund_id, "currency": currency})
                for k, v in deltas2.items():
                    value_delta2[sedol][k] += v
                    post_flow_map[(k, fund_id, sedol)] = post_flow_map.get((k,fund_id,sedol),0.0) + v
                    fund_totals[(k,fund_id)] = fund_totals.get((k,fund_id),0.0) + v
                    tgt = fund_target_map.get((k,fund_id),0.0)
                    fund_dev[(k,fund_id)] = fund_totals[(k,fund_id)] - tgt
                all_txns.extend(txns_uw)
                resid_sell_after = sum(x["remaining_value"] for x in resid_sells2)
                if resid_sell_after > 1e-9:
                    units = round(resid_sell_after / nav, unit_decimal_places) if nav != 0 else 0.0
                    external_rows.append({
                        "sedol": sedol, "fund_id": fund_id, "currency": currency,
                        "side": "External Redeem", "price": nav,
                        "units": units, "value": units * nav
                    })
            else:
                total_sell = sum(x["remaining_value"] for x in resid_sells)
                if total_sell > 1e-9:
                    units = round(total_sell / nav, unit_decimal_places) if nav != 0 else 0.0
                    external_rows.append({
                        "sedol": sedol, "fund_id": fund_id, "currency": currency,
                        "side": "External Redeem", "price": nav,
                        "units": units, "value": units * nav
                    })

    txns_df = pd.DataFrame(all_txns, columns=[
        "sedol","fund_id","currency","from_client","to_client","price","units","value","reason"
    ])
    external_df = pd.DataFrame(external_rows, columns=[
        "sedol","fund_id","currency","side","price","units","value"
    ])

    # Build SEDOL-level summary
    summary_rows = []
    for (cid,fid,sed), val in post_flow_map.items():
        summary_rows.append({
            "client_id": cid, "sedol": sed, "fund_id": fid, "post_trade_value": val
        })
    summary_df = pd.DataFrame(summary_rows)
    if not summary_df.empty:
        meta = holdings.groupby(["sedol","fund_id"], sort=False).agg(
            currency=("currency","first"),
            price=("nav","max")
        ).reset_index().rename(columns={"price":"nav"})
        summary_df = summary_df.merge(meta, on=["sedol","fund_id"], how="left")

    txns_df.to_csv(transactions_out, index=False)
    external_df.to_csv(external_out, index=False)
    summary_df.to_csv(summary_out, index=False)

    return txns_df, external_df, summary_df

if __name__ == "__main__":
    import argparse
    ap = argparse.ArgumentParser(description="Inter-client matching engine (two-file, fund-level targets across multiple SEDOLs).")
    ap.add_argument("blotter_csv", help="Blotter orders CSV")
    ap.add_argument("holdings_csv", help="Holdings vs target CSV")
    ap.add_argument("--transactions_out", default="transactions_internal.csv")
    ap.add_argument("--external_out", default="net_external_per_sedol.csv")
    ap.add_argument("--summary_out", default="post_trade_summary.csv")
    ap.add_argument("--unit_decimal_places", type=int, default=6)
    ap.add_argument("--min_ticket_value", type=float, default=0.0)
    args = ap.parse_args()

    run_matching_engine_twofile_fundlevel(
        args.blotter_csv, args.holdings_csv,
        transactions_out=args.transactions_out,
        external_out=args.external_out,
        summary_out=args.summary_out,
        unit_decimal_places=args.unit_decimal_places,
        min_ticket_value=args.min_ticket_value
